<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sketch工具</title>
    <style>
        /* A simple CSS reset that removes the default margin, padding, and border of all elements */
        * {
            margin: 0;
        }

        /*
          5. Improve media defaults
        */
        img,
        picture,
        video,
        canvas,
        svg {
            display: block;
            max-width: 100%;
        }

        /*
          6. Remove built-in form typography styles
        */
        input,
        button,
        textarea,
        select {
            font: inherit;
        }

        /*
          7. Avoid text overflows
        */
        p,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            overflow-wrap: break-word;
        }

        /*
          8. Create a root stacking context
        */
        #root,
        #__next {
            isolation: isolate;
        }

        code,
        kbd,
        samp {
            font-family: monospace, monospace;
            /* 1 */
            font-size: 1em;
            /* 2 */
        }

        p {
            font-family: "Trebuchet MS", Verdana, sans-serif;
        }



        @supports (-webkit-touch-callout: none) {
            body {
                -webkit-user-select: none;
                -webkit-tap-highlight-color: transparent;
                /* Disable tap highlight */
            }
        }

        html {
            -webkit-user-select: none;
            /* Disable text selection */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            /* Disable tap highlight */
        }

        #cursor, #snap-cursor {
            position: absolute;
            display: none;
            z-index: 1000;
            transition: all 0.1s ease-out;
        }
        
        /* 移除原有的吸附样式 */
        #cursor.snapping {
            /* 所有的吸附效果都通过切换SVG实现，不再使用CSS变换 */
        }

        .rectangle {
            position: absolute;
            border: 2px solid #0696D7;
            display: none;
        }

        /* CSS */
        #grid-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: auto;
            z-index: 0;
        }

        .grid-item {
            position: absolute;
            border: 1px solid rgba(203, 203, 203, 0.20);
            box-sizing: border-box;
            z-index: 0;
        }

        .grid-item.thick-right {
            border-right-width: 1px;
            z-index: 0;

        }

        .grid-item.thick-bottom {
            border-bottom-width: 1px;
            z-index: 0;
        }

        .middle-vertical {
            border-right-color: green !important;
            z-index: 100;
        }

        .middle-horizontal {
            border-bottom-color: red !important;
            z-index: 100;
        }

        .toolbar {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 60px;
            min-height: 60px; /* 确保最小高度 */
            background-color: #F5F5F5;
            z-index: 1000;
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: center;
            padding-left: 16px;
            box-sizing: border-box; /* 确保padding不影响总高度 */
        }
        
        
        /* icon-button 基础样式 */
        .icon-button {
            display: flex;
            width: 36px; /* 固定尺寸 */
            height: 36px; /* 固定尺寸 */
            padding: 4px; /* 固定padding */
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            border-radius: 2px;
            background: rgba(250, 250, 250, 0.00);
            border: none;
            cursor: pointer;
            margin: 0 8px 0 0;
        }
        
        /* hover状态 - 使用伪类 */
        .icon-button:hover:not(.active) {
            background: rgba(128, 128, 128, 0.10);
        }
        
        /* pressed状态 - 使用伪类 */
        .icon-button:active:not(.active) {
            background: rgba(128, 128, 128, 0.20);
        }
        
        /* on状态 - 使用类选择器 */
        .icon-button.active {
            border: 1px solid rgba(6, 150, 215, 0.50);
            background: rgba(205, 234, 247, 0.60);    
        }
        
        /* 图标样式 */
        .icon-svg {
            width: 24px;
            height: 24px;
            fill: #333;
        }
        
        /* 根据媒体查询调整按钮间距 */
        @media only screen and (max-width: 430px) {
            .toolbar {
                padding-left: 8px;
                height: 60px; /* 保持一致高度 */
            }
            
            .icon-button {
                margin: 0 8px 0 0; /* 增加间距确保可点击 */
                width: 40px; /* 移动设备上增大点击区域 */
                height: 40px;
            }

            /* 图标尺寸保持不变 */
            .icon-svg {
                width: 24px;
                height: 24px;
            }

            .snackbar {
                padding: 10px 12px;
                font-size: 14px;
            }
        }

        .snackbar {
            position: fixed; /* 改为固定定位 */
            left: 50%;
            transform: translateX(-50%);
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            width: 300px; /* 固定宽度 */
            max-width: 90vw; /* 最大宽度 */
            z-index: 2000;
            top: 80px;
            padding: 12px 16px; /* 增加内边距 */
            border-radius: 4px;
            font-size: 16px; /* 确保字体大小 */
            text-align: center; /* 居中文本 */
            box-sizing: border-box; /* 确保padding不影响总宽度 */
            transition: opacity 0.2s ease-out; /* 添加提示信息的过渡效果 */
        }

        .snackbar p {
            margin: 0;
            line-height: 1.4;
        }

        .proposal-selector {
            margin-left: auto; /* 将下拉菜单推到右侧 */
            margin-right: 16px;
            display: flex;
            align-items: center;
        }
        
        #proposal-dropdown {
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: white;
            font-size: 14px;
            cursor: pointer;
            outline: none;
        }
        
        #proposal-dropdown:hover {
            border-color: #0696D7;
        }

        /* 添加维度标注的样式 */
        .dimension-label {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ccc;
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
            z-index: 500;
            color: #0696D7;
            white-space: nowrap;
            text-align: center;
            transform: translate(-50%, -50%);
        }

        .dimension-line {
            position: absolute;
            background-color: #CCCCCC; /* 改为浅灰色 */
            height: 1px;
            pointer-events: none;
            z-index: 450;
        }

        .dimension-marker {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #0696D7;
            border-radius: 50%;
            pointer-events: none;
            z-index: 450;
            transform: translate(-50%, -50%);
        }

        .extension-line {
            position: absolute;
            background-color: #CCCCCC; /* 浅灰色 */
            width: 1px;
            height: 10px;
            pointer-events: none;
            z-index: 440;
        }
    </style>
</head>

<body>
    <div class="snackbar">
    </div>
    <div class="toolbar">
        <!-- 三个初始状态的按钮 -->

        <button class="icon-button">
            <img class="icon-svg" src="assets/Square.svg" alt="Square 图标"/>
        </button>

        <button class="icon-button">
            <img class="icon-svg" src="assets/Circle.svg" alt="Circle 图标"/>
        </button>

        <button class="icon-button">
            <img class="icon-svg" src="assets/Line.svg" alt="Line 图标"/>
        </button>
        
        <!-- 添加下拉菜单，用于选择方案 -->
        <div class="proposal-selector">
            <select id="proposal-dropdown">
                <option value="proposal1" selected>Proposal 1</option>
                <option value="proposal2">Proposal 2</option>
            </select>
        </div>
    </div>
    
    <!-- 标准光标 -->
    <svg id="cursor" width="71" height="71" viewBox="0 0 71 71" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M36 7L36 4L35 4L35 7L36 7Z" fill="white"/>
        <path d="M64 36L67 36L67 35L64 35L64 36Z" fill="white"/>
        <path d="M36 18V13H35V18H36Z" fill="white"/>
        <path d="M53 36L58 36L58 35L53 35L53 36Z" fill="white"/>
        <path d="M36 30V24H35V30H36Z" fill="white"/>
        <path d="M41 36L47 36L47 35L41 35L41 36Z" fill="white"/>
        <path d="M36 13V8L35 8V13H36Z" fill="#3C3C3C"/>
        <path d="M58 36L63 36L63 35L58 35L58 36Z" fill="#3C3C3C"/>
        <path d="M35 0L35 3L36 3L36 -8.74228e-08L35 0Z" fill="#3C3C3C"/>
        <path d="M71 35L68 35L68 36L71 36L71 35Z" fill="#3C3C3C"/>
        <path d="M36 24V18H35V24H36Z" fill="#3C3C3C"/>
        <path d="M47 36L53 36L53 35L47 35L47 36Z" fill="#3C3C3C"/>
        <path d="M35 64L35 67L36 67L36 64L35 64Z" fill="white"/>
        <path d="M7 35L4 35L4 36L7 36L7 35Z" fill="white"/>
        <path d="M35 53L35 58L36 58L36 53L35 53Z" fill="white"/>
        <path d="M18 35L13 35L13 36L18 36L18 35Z" fill="white"/>
        <path d="M35 41L35 47L36 47L36 41L35 41Z" fill="white"/>
        <path d="M30 35L24 35L24 36L30 36L30 35Z" fill="white"/>
        <path d="M35 58L35 63L36 63L36 58L35 58Z" fill="#3C3C3C"/>
        <path d="M13 35L8 35L8 36L13 36L13 35Z" fill="#3C3C3C"/>
        <path d="M36 71L36 68H35L35 71H36Z" fill="#3C3C3C"/>
        <path d="M0 36L3 36L3 35L4.37114e-08 35L0 36Z" fill="#3C3C3C"/>
        <path d="M35 47L35 53L36 53L36 47L35 47Z" fill="#3C3C3C"/>
        <path d="M24 35L18 35L18 36L24 36L24 35Z" fill="#3C3C3C"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M29.327 30.638C29 31.2798 29 32.1198 29 33.8V37.2C29 38.8802 29 39.7202 29.327 40.362C29.6146 40.9265 30.0735 41.3854 30.638 41.673C31.2798 42 32.1198 42 33.8 42H37.2C38.8802 42 39.7202 42 40.362 41.673C40.9265 41.3854 41.3854 40.9265 41.673 40.362C42 39.7202 42 38.8802 42 37.2V33.8C42 32.1198 42 31.2798 41.673 30.638C41.3854 30.0735 40.9265 29.6146 40.362 29.327C39.7202 29 38.8802 29 37.2 29H33.8C32.1198 29 31.2798 29 30.638 29.327C30.0735 29.6146 29.6146 30.0735 29.327 30.638ZM30.218 31.092C30 31.5198 30 32.0799 30 33.2V37.8C30 38.9201 30 39.4802 30.218 39.908C30.4097 40.2843 30.7157 40.5903 31.092 40.782C31.5198 41 32.0799 41 33.2 41H37.8C38.9201 41 39.4802 41 39.908 40.782C40.2843 40.5903 40.5903 40.2843 40.782 39.908C41 39.4802 41 38.9201 41 37.8V33.2C41 32.0799 41 31.5198 40.782 31.092C40.5903 30.7157 40.2843 30.4097 39.908 30.218C39.4802 30 38.9201 30 37.8 30H33.2C32.0799 30 31.5198 30 31.092 30.218C30.7157 30.4097 30.4097 30.7157 30.218 31.092Z" fill="white"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M30.218 31.092C30 31.5198 30 32.0799 30 33.2V37.8C30 38.9201 30 39.4802 30.218 39.908C30.4097 40.2843 30.7157 40.5903 31.092 40.782C31.5198 41 32.0799 41 33.2 41H37.8C38.9201 41 39.4802 41 39.908 40.782C40.2843 40.5903 40.5903 40.2843 40.782 39.908C41 39.4802 41 38.9201 41 37.8V33.2C41 32.0799 41 31.5198 40.782 31.092C40.5903 30.7157 40.2843 30.4097 39.908 30.218C39.4802 30 38.9201 30 37.8 30H33.2C32.0799 30 31.5198 30 31.092 30.218C30.7157 30.4097 30.4097 30.7157 30.218 31.092ZM31.109 31.546C31 31.7599 31 32.0399 31 32.6V38.4C31 38.9601 31 39.2401 31.109 39.454C31.2049 39.6422 31.3578 39.7951 31.546 39.891C31.7599 40 32.0399 40 32.6 40H38.4C38.9601 40 39.2401 40 39.454 39.891C39.6422 39.7951 39.7951 39.6422 39.891 39.454C40 39.2401 40 38.9601 40 38.4V32.6C40 32.0399 40 31.7599 39.891 31.546C39.7951 31.3578 39.6422 31.2049 39.454 31.109C39.2401 31 38.9601 31 38.4 31H32.6C32.0399 31 31.7599 31 31.546 31.109C31.3578 31.2049 31.2049 31.3578 31.109 31.546Z" fill="#3C3C3C"/>
    </svg>
    
    <!-- 吸附光标 -->
    <svg id="snap-cursor" class="cursor" width="71" height="71" viewBox="0 0 71 71" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
      <path d="M36 7L36 4L35 4L35 7L36 7Z" fill="white"/>
      <path d="M64 36L67 36L67 35L64 35L64 36Z" fill="white"/>
      <path d="M36 18V13H35V18H36Z" fill="white"/>
      <path d="M53 36L58 36L58 35L53 35L53 36Z" fill="white"/>
      <path d="M36 30V24H35V30H36Z" fill="white"/>
      <path d="M41 36L47 36L47 35L41 35L41 36Z" fill="white"/>
      <path d="M36 13V8L35 8V13H36Z" fill="#3C3C3C"/>
      <path d="M58 36L63 36L63 35L58 35L58 36Z" fill="#3C3C3C"/>
      <path d="M35 0L35 3L36 3L36 -8.74228e-08L35 0Z" fill="#3C3C3C"/>
      <path d="M71 35L68 35L68 36L71 36L71 35Z" fill="#3C3C3C"/>
      <path d="M36 24V18H35V24H36Z" fill="#3C3C3C"/>
      <path d="M47 36L53 36L53 35L47 35L47 36Z" fill="#3C3C3C"/>
      <path d="M35 64L35 67L36 67L36 64L35 64Z" fill="white"/>
      <path d="M7 35L4 35L4 36L7 36L7 35Z" fill="white"/>
      <path d="M35 53L35 58L36 58L36 53L35 53Z" fill="white"/>
      <path d="M18 35L13 35L13 36L18 36L18 35Z" fill="white"/>
      <path d="M35 41L35 47L36 47L36 41L35 41Z" fill="white"/>
      <path d="M30 35L24 35L24 36L30 36L30 35Z" fill="white"/>
      <path d="M35 58L35 63L36 63L36 58L35 58Z" fill="#3C3C3C"/>
      <path d="M13 35L8 35L8 36L13 36L13 35Z" fill="#3C3C3C"/>
      <path d="M36 71L36 68H35L35 71H36Z" fill="#3C3C3C"/>
      <path d="M0 36L3 36L3 35L4.37114e-08 35L0 36Z" fill="#3C3C3C"/>
      <path d="M35 47L35 53L36 53L36 47L35 47Z" fill="#3C3C3C"/>
      <path d="M24 35L18 35L18 36L24 36L24 35Z" fill="#3C3C3C"/>
      <path d="M37.2002 29C38.8802 29 39.7206 29.0002 40.3623 29.3271C40.9265 29.6147 41.3853 30.0735 41.6729 30.6377C41.9998 31.2794 42 32.1198 42 33.7998V37.2002C42 38.8802 41.9998 39.7206 41.6729 40.3623C41.3853 40.9265 40.9265 41.3853 40.3623 41.6729C39.7206 41.9998 38.8802 42 37.2002 42H33.7998C32.1198 42 31.2794 41.9998 30.6377 41.6729C30.0735 41.3853 29.6147 40.9265 29.3271 40.3623C29.0002 39.7206 29 38.8802 29 37.2002V33.7998C29 32.1198 29.0002 31.2794 29.3271 30.6377C29.6147 30.0735 30.0735 29.6147 30.6377 29.3271C31.2794 29.0002 32.1198 29 33.7998 29H37.2002ZM33.2002 30C32.0801 30 31.5196 29.9998 31.0918 30.2178C30.7155 30.4095 30.4095 30.7155 30.2178 31.0918C29.9998 31.5196 30 32.0801 30 33.2002V37.7998C30 38.9199 29.9998 39.4804 30.2178 39.9082C30.4095 40.2845 30.7155 40.5905 31.0918 40.7822C31.5196 41.0002 32.0801 41 33.2002 41H37.7998C38.9199 41 39.4804 41.0002 39.9082 40.7822C40.2845 40.5905 40.5905 40.2845 40.7822 39.9082C41.0002 39.4804 41 38.9199 41 37.7998V33.2002C41 32.0801 41.0002 31.5196 40.7822 31.0918C40.5905 30.7155 40.2845 30.4095 39.9082 30.2178C39.4804 29.9998 38.9199 30 37.7998 30H33.2002Z" fill="#0696D7" fill-opacity="0.35"/>
      <path d="M37.7998 30C38.9199 30 39.4804 29.9998 39.9082 30.2178C40.2845 30.4095 40.5905 30.7155 40.7822 31.0918C41.0002 31.5196 41 32.0801 41 33.2002V37.7998C41 38.9199 41.0002 39.4804 40.7822 39.9082C40.5905 40.2845 40.2845 40.5905 39.9082 40.7822C39.4804 41.0002 38.9199 41 37.7998 41H33.2002C32.0801 41 31.5196 41.0002 31.0918 40.7822C30.7155 40.5905 30.4095 40.2845 30.2178 39.9082C29.9998 39.4804 30 38.9199 30 37.7998V33.2002C30 32.0801 29.9998 31.5196 30.2178 31.0918C30.4095 30.7155 30.7155 30.4095 31.0918 30.2178C31.5196 29.9998 32.0801 30 33.2002 30H37.7998ZM32.5996 31C32.0398 31 31.7598 31.0004 31.5459 31.1094C31.3579 31.2052 31.2052 31.3579 31.1094 31.5459C31.0004 31.7598 31 32.0398 31 32.5996V38.4004C31 38.9602 31.0004 39.2402 31.1094 39.4541C31.2052 39.6421 31.3579 39.7948 31.5459 39.8906C31.7598 39.9996 32.0398 40 32.5996 40H38.4004C38.9602 40 39.2402 39.9996 39.4541 39.8906C39.6421 39.7948 39.7948 39.6421 39.8906 39.4541C39.9996 39.2402 40 38.9602 40 38.4004V32.5996C40 32.0398 39.9996 31.7598 39.8906 31.5459C39.7948 31.3579 39.6421 31.2052 39.4541 31.1094C39.2402 31.0004 38.9602 31 38.4004 31H32.5996Z" fill="#0696D7"/>
    </svg>

    <div id="grid-container"></div>


    <script>
        // 基础配置工厂，用于创建不同方案的配置
        class ProposalConfigFactory {
            static createConfig(proposalType) {
                switch(proposalType) {
                    case 'proposal1':
                        return {
                            // Proposal 1 的配置
                            gridSize: 25,
                            snapThreshold: 8,
                            shapes: {
                                square: {
                                    initMessages: {
                                        first: 'Draw a rectangle: touch and move the cursor, lift your finger to place the first point',
                                        firstPlaced: 'The first point has been placed, touch and move again to place the second point',
                                        completed: 'The rectangle has been completed, touch and move again to place the first point of the new rectangle'
                                    },
                                    style: {
                                        border: '1px solid #76C7EB',
                                        background: 'rgba(137, 205, 236, 0.15)'
                                    }
                                },
                                circle: {
                                    initMessages: {
                                        first: 'Draw a circle: touch and move the cursor, lift your finger to place the center',
                                        firstPlaced: 'The center has been placed, touch and move again to determine the radius',
                                        completed: 'The circle has been completed, touch and move again to place the center of the new circle'
                                    },
                                    style: {
                                        border: '1px solid #76C7EB',
                                        background: 'rgba(137, 205, 236, 0.15)'
                                    }
                                },
                                line: {
                                    initMessages: {
                                        first: 'Draw a line: touch and move the cursor, lift your finger to place the starting point',
                                        firstPlaced: 'The starting point has been placed, touch and move again to place the end point',
                                        completed: 'The line has been completed, touch and move again to place the starting point of the new line'
                                    },
                                    style: {
                                        color: '#76C7EB',
                                        width: '2px'
                                    }
                                }
                            }
                        };
                    case 'proposal2':
                        return {
                            // Proposal 2 的配置，稍后会根据需求填充具体内容
                            // 暂时使用与proposal1相同的配置
                            gridSize: 25,
                            snapThreshold: 8,
                            shapes: {
                                square: {
                                    initMessages: {
                                        first: 'Draw a rectangle: touch and move the cursor, lift your finger to place the first point',
                                        firstPlaced: 'The first point has been placed, touch and move again to place the second point',
                                        completed: 'The rectangle has been completed, touch and move again to place the first point of the new rectangle'
                                    },
                                    style: {
                                        border: '1px solid #76C7EB',
                                        background: 'rgba(137, 205, 236, 0.15)'
                                    }
                                },
                                circle: {
                                    initMessages: {
                                        first: 'Draw a circle: touch and move the cursor, lift your finger to place the center',
                                        firstPlaced: 'The center has been placed, touch and move again to determine the radius',
                                        completed: 'The circle has been completed, touch and move again to place the center of the new circle'
                                    },
                                    style: {
                                        border: '1px solid #76C7EB',
                                        background: 'rgba(137, 205, 236, 0.15)'
                                    }
                                },
                                line: {
                                    initMessages: {
                                        first: 'Draw a line: touch and move the cursor, lift your finger to place the starting point',
                                        firstPlaced: 'The starting point has been placed, touch and move again to place the end point',
                                        completed: 'The line has been completed, touch and move again to place the starting point of the new line'
                                    },
                                    style: {
                                        color: '#76C7EB',
                                        width: '2px'
                                    }
                                }
                            }
                        };
                    default:
                        throw new Error(`Unknown proposal type: ${proposalType}`);
                }
            }
        }

        // 形状绘制管理器类
        class ShapeDrawer {
            constructor() {
                // DOM元素
                this.cursor = document.getElementById('cursor');
                this.snapCursor = document.getElementById('snap-cursor');
                this.snackbar = document.querySelector('.snackbar');
                this.proposalDropdown = document.getElementById('proposal-dropdown');
                
                // 状态变量
                this.start = null;
                this.isDrawing = false;
                this.firstCornerPlaced = false;
                this.shapeCount = 0;
                this.currentShape = null;
                this.activeShape = null;
                
                // 维度标注相关
                this.dimensionElements = {
                    labels: [],
                    lines: [],
                    markers: []
                };
                this.currentDimension = null;
                
                // 初始化当前方案配置
                this.currentProposal = this.proposalDropdown.value;
                this.updateConfig();
                
                // 网格吸附相关
                this.isSnapping = false; // 是否正在吸附
                
                // 初始化
                this.setupEventListeners();
                this.positionCursorAtCenter();
            }
            
            // 更新当前配置
            updateConfig() {
                const config = ProposalConfigFactory.createConfig(this.currentProposal);
                this.config = config;
                this.gridSize = config.gridSize;
                this.snapThreshold = config.snapThreshold;
                
                // 重置工具选择
                document.querySelectorAll('.icon-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.activeShape = null;
                this.cursor.style.display = 'none';
                this.snapCursor.style.display = 'none';
                this.isDrawing = false;
                this.firstCornerPlaced = false;
                
                // 重绘网格
                this.redrawGrid();
            }

            // 重绘网格
            redrawGrid() {
                const gridContainer = document.getElementById('grid-container');
                gridContainer.innerHTML = ''; // 清空现有网格
                
                // 固定网格大小
                const squareSize = this.gridSize;
                
                const squaresPerRow = Math.ceil(window.innerWidth / squareSize);
                const squaresPerColumn = Math.ceil(window.innerHeight / squareSize);

                // 创建网格
                for (let y = 0; y < squaresPerColumn; y++) {
                    for (let x = 0; x < squaresPerRow; x++) {
                        const div = document.createElement('div');
                        div.classList.add('grid-item');
                        if ((x + 1) % 5 === 0) div.classList.add('thick-right');
                        if ((y + 1) % 5 === 0) div.classList.add('thick-bottom');
                        if (x === Math.floor(squaresPerRow / 2)) div.classList.add('middle-vertical');
                        if (y === Math.floor(squaresPerColumn / 2)) div.classList.add('middle-horizontal');
                        div.style.width = `${squareSize}px`;
                        div.style.height = `${squareSize}px`;
                        div.style.left = `${x * squareSize}px`;
                        div.style.top = `${y * squareSize}px`;
                        gridContainer.appendChild(div);
                    }
                }
            }
            
            // 设置事件监听器
            setupEventListeners() {
                // 工具按钮点击事件
                document.querySelectorAll('.icon-button').forEach((button, index) => {
                    button.addEventListener('click', () => {
                        this.handleToolSelection(button, index);
                    });
                });
                
                // 方案下拉菜单变更事件
                this.proposalDropdown.addEventListener('change', () => {
                    const previousProposal = this.currentProposal;
                    this.currentProposal = this.proposalDropdown.value;
                    
                    // 更新配置 (这会重置工具选择和网格)
                    this.updateConfig();
                    
                    // 清除所有的维度标注
                    this.clearAllDimensions();
                    
                    // 清空画布，移除所有已绘制的图形
                    this.clearAllShapes();
                    
                    // 重置状态
                    this.start = null;
                    this.isDrawing = false;
                    this.firstCornerPlaced = false;
                    this.shapeCount = 0;
                    this.currentShape = null;
                    this.activeShape = null;
                    
                    // 更新提示信息
                    this.snackbar.innerHTML = `<p>Switched to ${this.currentProposal}</p>`;
                });
                
                // 触摸事件
                document.addEventListener('touchstart', (e) => {
                    // 检查触摸点是否在工具按钮上，如果是则不阻止默认行为
                    const target = e.target;
                    if (target.closest('.icon-button') || target.classList.contains('icon-svg') || 
                        target.closest('.proposal-selector')) {
                        return; // 允许按钮和下拉菜单的默认点击行为
                    }
                    
                    // 根据不同的proposal处理不同的触摸逻辑
                    if (this.currentProposal === 'proposal1') {
                        this.handleTouchStartProposal1(e);
                    } else {
                        this.handleTouchStart(e);
                    }
                });
                
                document.addEventListener('touchmove', (e) => {
                    // 根据不同的proposal处理不同的触摸移动逻辑
                    if (this.currentProposal === 'proposal1') {
                        this.handleTouchMoveProposal1(e);
                    } else {
                        this.handleTouchMove(e);
                    }
                });
                
                document.addEventListener('touchend', (e) => {
                    // 同样检查触摸结束点是否在按钮上
                    const target = e.target;
                    if (target.closest('.icon-button') || target.classList.contains('icon-svg') || 
                        target.closest('.proposal-selector')) {
                        return; // 允许按钮和下拉菜单的默认点击行为
                    }
                    
                    // 根据不同的proposal处理不同的触摸结束逻辑
                    if (this.currentProposal === 'proposal1') {
                        this.handleTouchEndProposal1(e);
                    } else {
                        this.handleTouchEnd(e);
                    }
                });
                
                // 添加鼠标事件支持
                document.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // 阻止页面拖动刷新 - 只对触摸事件
                document.addEventListener('touchmove', (e) => {
                    // 不要阻止工具栏上的触摸移动
                    if (e.target.closest('.toolbar') || e.target.closest('.icon-button')) {
                        return;
                    }
                    e.preventDefault();
                }, { passive: false });
            }
            
            // 将光标定位到屏幕中央
            positionCursorAtCenter() {
                const centerY = (window.innerHeight / 2 - 35);
                const centerX = (window.innerWidth / 2 - 35);
                
                this.cursor.style.top = centerY + 'px';
                this.cursor.style.left = centerX + 'px';
                this.snapCursor.style.top = centerY + 'px';
                this.snapCursor.style.left = centerX + 'px';
                
                // 初始不显示光标，只有选择工具后才显示
                this.cursor.style.display = 'none';
                this.snapCursor.style.display = 'none';
                
                this.snackbar.style.display = 'block';
                this.snackbar.innerHTML = '<p>Select a drawing tool</p>';
            }
            
            // 新增：检查位置是否在toolbar区域
            isPositionInToolbarArea(x, y) {
                // 获取工具栏元素
                const toolbar = document.querySelector('.toolbar');
                if (!toolbar) return false;
                
                // 获取工具栏的位置和尺寸
                const rect = toolbar.getBoundingClientRect();
                
                // 检查位置是否在工具栏区域内
                return (
                    x >= rect.left && 
                    x <= rect.right && 
                    y >= rect.top && 
                    y <= rect.bottom
                );
            }
            
            // 新增：检查元素是否在toolbar区域
            isInToolbarArea(element) {
                return element.closest('.toolbar') || element.classList.contains('icon-button') || 
                       element.classList.contains('icon-svg');
            }
            
            // 处理工具选择
            handleToolSelection(button, index) {
                // 如果已经是active状态，则取消选择
                if (button.classList.contains('active')) {
                    button.classList.remove('active');
                    this.activeShape = null;
                    this.cursor.style.display = 'none';
                    this.snapCursor.style.display = 'none';
                    this.snackbar.innerHTML = '<p>Select a drawing tool</p>';
                    
                    // 清除所有维度标注
                    this.clearAllDimensions();
                } else {
                    // 移除其他按钮的active状态
                    document.querySelectorAll('.icon-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // 为当前按钮添加active类
                    button.classList.add('active');
                    
                    // 设置当前形状类型
                    const shapeTypes = ['square', 'circle', 'line'];
                    this.activeShape = shapeTypes[index];
                    
                    // 更新提示信息
                    const tipMessage = this.config.shapes[this.activeShape].initMessages.first;
                    this.snackbar.innerHTML = `<p>${tipMessage}</p>`;
                    
                    // 根据不同的proposal处理光标显示逻辑
                    if (this.currentProposal === 'proposal2') {
                        // Proposal 2: 选择工具后，立即在屏幕中央显示光标
                        const centerY = (window.innerHeight / 2 - 35);
                        const centerX = (window.innerWidth / 2 - 35);
                        
                        this.cursor.style.top = centerY + 'px';
                        this.cursor.style.left = centerX + 'px';
                        this.snapCursor.style.top = centerY + 'px';
                        this.snapCursor.style.left = centerX + 'px';
                        
                        this.cursor.style.display = 'block';
                        this.snapCursor.style.display = 'none';
                    } else {
                        // Proposal 1: 选择工具后不显示光标，等待触摸事件
                        this.cursor.style.display = 'none';
                        this.snapCursor.style.display = 'none';
                    }
                    
                    // 清除所有维度标注
                    this.clearAllDimensions();
                }
            }
            
            // 新增：处理鼠标按下事件
            handleMouseDown(e) {
                // 检查位置是否在工具栏区域
                if (this.isPositionInToolbarArea(e.clientX, e.clientY) || this.isInToolbarArea(e.target)) {
                    this.cursor.style.display = 'none';
                    this.snapCursor.style.display = 'none';
                    return;
                }
                
                // 如果没有选择绘图工具，不执行操作
                if (!this.activeShape) return;
                
                // 光标跟随鼠标移动，向上偏移60像素
                this.cursor.style.top = (e.clientY - 35 - 60) + 'px';
                this.cursor.style.left = (e.clientX - 35) + 'px';
                this.cursor.style.display = 'block';
                
                // 如果是第二次点击且第一个点已经放置，准备绘制形状
                if (this.firstCornerPlaced) {
                    this.isDrawing = true;
                    
                    const secondPointMessages = {
                        'square': 'Move and click the mouse to place the second point of the rectangle',
                        'circle': 'Move and click the mouse to determine the radius of the circle',
                        'line': 'Move and click the mouse to place the end point of the line'
                    };
                    this.snackbar.innerHTML = `<p>${secondPointMessages[this.activeShape]}</p>`;
                }
            }
            
            // 修改：计算最近的网格点，只吸附到交叉点
            getNearestGridPoint(x, y) {
                // 计算最近的网格交叉点坐标
                const nearestX = Math.round(x / this.gridSize) * this.gridSize;
                const nearestY = Math.round(y / this.gridSize) * this.gridSize;
                
                // 计算到最近网格交叉点的欧几里德距离
                const distance = Math.sqrt(
                    Math.pow(x - nearestX, 2) + 
                    Math.pow(y - nearestY, 2)
                );
                
                // 如果距离小于阈值，返回网格交叉点坐标
                if (distance <= this.snapThreshold) {
                    return {
                        x: nearestX,
                        y: nearestY,
                        isSnapping: true
                    };
                }
                
                // 不符合吸附条件，返回原始坐标
                return { x, y, isSnapping: false };
            }
            
            // 修改：更新光标吸附状态 - 只切换光标样式，不修改提示信息
            updateSnappingState(isSnapping) {
                if (isSnapping !== this.isSnapping) {
                    this.isSnapping = isSnapping;
                    
                    if (isSnapping) {
                        // 切换到吸附光标
                        this.cursor.style.display = 'none';
                        this.snapCursor.style.display = 'block';
                    } else {
                        // 切换到标准光标
                        this.cursor.style.display = 'block';
                        this.snapCursor.style.display = 'none';
                    }
                }
            }
            
            // 修改：处理鼠标移动事件
            handleMouseMove(e) {
                // 检查位置是否在工具栏区域
                if (this.isPositionInToolbarArea(e.clientX, e.clientY) || this.isInToolbarArea(e.target)) {
                    this.cursor.style.display = 'none';
                    this.snapCursor.style.display = 'none';
                    return;
                }
                
                // 如果没有选择绘图工具，不执行操作但仍然显示光标
                if (!this.activeShape) {
                    return;
                }
                
                // 计算鼠标位置（考虑工具栏偏移）
                const mouseX = e.clientX;
                const mouseY = e.clientY - 60; // 减去工具栏高度
                
                // 获取最近的网格点
                const { x: snappedX, y: snappedY, isSnapping } = this.getNearestGridPoint(mouseX, mouseY);
                
                // 更新光标位置（两种光标都更新位置）
                const cursorTop = (snappedY - 35) + 'px';
                const cursorLeft = (snappedX - 35) + 'px';
                
                this.cursor.style.top = cursorTop;
                this.cursor.style.left = cursorLeft;
                this.snapCursor.style.top = cursorTop;
                this.snapCursor.style.left = cursorLeft;
                
                // 更新吸附状态（显示相应的光标）
                this.updateSnappingState(isSnapping);
                
                // 如果正在绘制形状，根据不同形状类型进行处理
                if (this.isDrawing && this.start) {
                    // 使用吸附后的位置作为当前点
                    const currentX = snappedX;
                    const currentY = snappedY;
                    
                    switch (this.activeShape) {
                        case 'square':
                            this.updateSquare(currentX, currentY);
                            break;
                        case 'circle':
                            this.updateCircle(currentX, currentY);
                            break;
                        case 'line':
                            this.updateLine(currentX, currentY);
                            break;
                    }
                }
            }
            
            // 处理触摸开始事件
            handleTouchStart(e) {
                e.preventDefault();
                
                // 如果触摸在工具栏区域，隐藏光标
                if (this.isInToolbarArea(e.target)) {
                    this.cursor.style.display = 'none';
                    this.snapCursor.style.display = 'none';
                    return;
                }
                
                // 如果没有选择绘图工具，不执行操作
                if (!this.activeShape) return;
                
                // 计算触摸位置（考虑工具栏偏移）
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY - 60; // 减去工具栏高度
                
                // 获取最近的网格点
                const { x: snappedX, y: snappedY, isSnapping } = this.getNearestGridPoint(touchX, touchY);
                
                // 更新光标位置（两种光标都更新位置）
                const cursorTop = (snappedY - 35) + 'px';
                const cursorLeft = (snappedX - 35) + 'px';
                
                this.cursor.style.top = cursorTop;
                this.cursor.style.left = cursorLeft;
                this.snapCursor.style.top = cursorTop;
                this.snapCursor.style.left = cursorLeft;
                
                // 更新吸附状态（显示相应的光标）
                this.updateSnappingState(isSnapping);
                
                // 如果是第二次触摸且第一个点已经放置，准备绘制形状
                if (this.firstCornerPlaced) {
                    this.isDrawing = true;
                    
                    const secondPointMessages = {
                        'square': 'Move and lift your finger to place the second point of the rectangle',
                        'circle': 'Move and lift your finger to determine the radius of the circle',
                        'line': 'Move and lift your finger to place the end point of the line'
                    };
                    this.snackbar.innerHTML = `<p>${secondPointMessages[this.activeShape]}</p>`;
                }
            }
            
            // 修改：处理触摸移动事件
            handleTouchMove(e) {
                e.preventDefault();
                
                // 如果触摸在工具栏区域，隐藏光标
                if (this.isInToolbarArea(e.target)) {
                    this.cursor.style.display = 'none';
                    this.snapCursor.style.display = 'none';
                    return;
                }
                
                // 如果没有选择绘图工具，不执行操作
                if (!this.activeShape) return;
                
                // 计算触摸位置（考虑工具栏偏移）
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY - 60; // 减去工具栏高度
                
                // 获取最近的网格点
                const { x: snappedX, y: snappedY, isSnapping } = this.getNearestGridPoint(touchX, touchY);
                
                // 更新光标位置（两种光标都更新位置）
                const cursorTop = (snappedY - 35) + 'px';
                const cursorLeft = (snappedX - 35) + 'px';
                
                this.cursor.style.top = cursorTop;
                this.cursor.style.left = cursorLeft;
                this.snapCursor.style.top = cursorTop;
                this.snapCursor.style.left = cursorLeft;
                
                // 更新吸附状态（显示相应的光标）
                this.updateSnappingState(isSnapping);
                
                // 如果正在绘制形状，根据不同形状类型进行处理
                if (this.isDrawing && this.start) {
                    // 使用吸附后的位置作为当前点
                    const currentX = snappedX;
                    const currentY = snappedY;
                    
                    switch (this.activeShape) {
                        case 'square':
                            this.updateSquare(currentX, currentY);
                            break;
                        case 'circle':
                            this.updateCircle(currentX, currentY);
                            break;
                        case 'line':
                            this.updateLine(currentX, currentY);
                            break;
                    }
                }
            }
            
            // 修改：处理鼠标松开事件
            handleMouseUp(e) {
                // 检查位置是否在工具栏区域
                if (this.isPositionInToolbarArea(e.clientX, e.clientY) || this.isInToolbarArea(e.target)) {
                    return;
                }
                
                // 如果没有选择绘图工具，不执行操作
                if (!this.activeShape) return;
                
                // 第一次抬起，放置第一个点
                if (!this.firstCornerPlaced) {
                    // 如果要开始新图形，清除所有现有的维度标注
                    this.clearAllDimensions();
                    
                    // 创建新形状
                    this.currentShape = document.createElement('div');
                    this.currentShape.id = 'shape' + (++this.shapeCount);
                    this.currentShape.style.position = 'absolute';
                    document.body.appendChild(this.currentShape);
                    
                    // 记录起始点 - 使用当前显示的光标位置
                    const cursorX = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.left) + 35;
                    const cursorY = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.top) + 35;
                    this.start = { x: cursorX, y: cursorY };
                    
                    // 添加起始点标记
                    this.startMarker = this.addPointMarker(cursorX, cursorY, true);
                    
                    // 根据形状类型初始化
                    switch (this.activeShape) {
                        case 'square':
                            this.initSquare(cursorX, cursorY);
                            break;
                        case 'circle':
                            this.initCircle(cursorX, cursorY);
                            break;
                        case 'line':
                            this.initLine(cursorX, cursorY);
                            break;
                    }
                    
                    this.firstCornerPlaced = true;
                    
                    // 使用配置中的消息
                    const firstPointPlacedMessage = this.config.shapes[this.activeShape].initMessages.firstPlaced;
                    this.snackbar.innerHTML = `<p>${firstPointPlacedMessage}</p>`;
                } 
                // 第二次抬起，完成形状
                else if (this.isDrawing) {
                    this.isDrawing = false;
                    this.firstCornerPlaced = false;
                    
                    // 获取最后一个点的位置
                    const endX = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.left) + 35;
                    const endY = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.top) + 35;
                    
                    // 添加结束点标记（除了圆形外，因为圆形已经有中心点标记）
                    if (this.activeShape !== 'circle') {
                        this.addPointMarker(endX, endY, false);
                    }
                    
                    // 根据形状类型设置最终样式
                    switch (this.activeShape) {
                        case 'square':
                            this.currentShape.style.background = this.config.shapes.square.style.background;
                            break;
                        case 'circle':
                            this.currentShape.style.background = this.config.shapes.circle.style.background;
                            break;
                        case 'line':
                            // 线条已经有了样式
                            break;
                    }
                    
                    this.currentShape = null;
                    this.start = null;
                    
                    // 使用配置中的消息
                    const completionMessage = this.config.shapes[this.activeShape].initMessages.completed;
                    this.snackbar.innerHTML = `<p>${completionMessage}</p>`;
                }
            }
            
            // 处理触摸结束事件
            handleTouchEnd(e) {
                e.preventDefault();
                
                // 如果没有选择绘图工具，不执行操作
                if (!this.activeShape) return;
                
                // 第一次抬起，放置第一个点
                if (!this.firstCornerPlaced) {
                    // 如果要开始新图形，清除所有现有的维度标注
                    this.clearAllDimensions();
                    
                    // 创建新形状
                    this.currentShape = document.createElement('div');
                    this.currentShape.id = 'shape' + (++this.shapeCount);
                    this.currentShape.style.position = 'absolute';
                    document.body.appendChild(this.currentShape);
                    
                    // 记录起始点 - 使用当前显示的光标位置
                    const cursorX = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.left) + 35;
                    const cursorY = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.top) + 35;
                    this.start = { x: cursorX, y: cursorY };
                    
                    // 添加起始点标记
                    this.startMarker = this.addPointMarker(cursorX, cursorY, true);
                    
                    // 根据形状类型初始化
                    switch (this.activeShape) {
                        case 'square':
                            this.initSquare(cursorX, cursorY);
                            break;
                        case 'circle':
                            this.initCircle(cursorX, cursorY);
                            break;
                        case 'line':
                            this.initLine(cursorX, cursorY);
                            break;
                    }
                    
                    this.firstCornerPlaced = true;
                    
                    // 使用配置中的消息
                    const firstPointPlacedMessage = this.config.shapes[this.activeShape].initMessages.firstPlaced;
                    this.snackbar.innerHTML = `<p>${firstPointPlacedMessage}</p>`;
                } 
                // 第二次抬起，完成形状
                else if (this.isDrawing) {
                    this.isDrawing = false;
                    this.firstCornerPlaced = false;
                    
                    // 获取最后一个点的位置
                    const endX = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.left) + 35;
                    const endY = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.top) + 35;
                    
                    // 添加结束点标记（除了圆形外，因为圆形已经有中心点标记）
                    if (this.activeShape !== 'circle') {
                        this.addPointMarker(endX, endY, false);
                    }
                    
                    // 根据形状类型设置最终样式
                    switch (this.activeShape) {
                        case 'square':
                            this.currentShape.style.background = this.config.shapes.square.style.background;
                            break;
                        case 'circle':
                            this.currentShape.style.background = this.config.shapes.circle.style.background;
                            break;
                        case 'line':
                            // 线条已经有了样式
                            break;
                    }
                    
                    this.currentShape = null;
                    this.start = null;
                    
                    // 使用配置中的消息
                    const completionMessage = this.config.shapes[this.activeShape].initMessages.completed;
                    this.snackbar.innerHTML = `<p>${completionMessage}</p>`;
                }
            }
            
            // 初始化矩形
            initSquare(x, y) {
                this.currentShape.className = 'rectangle';
                this.currentShape.style.left = x + 'px';
                this.currentShape.style.top = y + 'px';
                this.currentShape.style.width = '0px';
                this.currentShape.style.height = '0px';
                this.currentShape.style.display = 'block';
                this.currentShape.style.border = '1px solid #C7C7C7';
                this.currentShape.style.boxSizing = 'border-box';
            }
            
            // 更新矩形大小
            updateSquare(currentX, currentY) {
                const width = currentX - this.start.x;
                const height = currentY - this.start.y;
                
                this.currentShape.style.width = Math.abs(width) + 'px';
                this.currentShape.style.height = Math.abs(height) + 'px';
                this.currentShape.style.border = this.config.shapes.square.style.border;
                
                // 处理负值情况
                let left = this.start.x;
                let top = this.start.y;
                
                if (width < 0) {
                    this.currentShape.style.left = currentX + 'px';
                    left = currentX;
                } else {
                    this.currentShape.style.left = this.start.x + 'px';
                }
                
                if (height < 0) {
                    this.currentShape.style.top = currentY + 'px';
                    top = currentY;
                } else {
                    this.currentShape.style.top = this.start.y + 'px';
                }
                
                // 更新维度标注
                this.updateRectangleDimensions(left, top, left + Math.abs(width), top + Math.abs(height));
            }
            
            // 初始化圆形
            initCircle(x, y) {
                this.currentShape.className = 'circle';
                this.currentShape.style.borderRadius = '50%';
                this.currentShape.style.left = x + 'px';
                this.currentShape.style.top = y + 'px';
                this.currentShape.style.width = '0px';
                this.currentShape.style.height = '0px';
                this.currentShape.style.display = 'block';
                this.currentShape.style.transform = 'translate(-50%, -50%)';
                this.currentShape.style.border = '1px solid #C7C7C7';
                this.currentShape.style.boxSizing = 'border-box';
            }
            
            // 更新圆形大小
            updateCircle(currentX, currentY) {
                // 计算半径 (欧几里得距离)
                const radius = Math.sqrt(
                    Math.pow(currentX - this.start.x, 2) + 
                    Math.pow(currentY - this.start.y, 2)
                );
                
                // 设置圆的直径
                this.currentShape.style.width = (radius * 2) + 'px';
                this.currentShape.style.height = (radius * 2) + 'px';
                this.currentShape.style.border = this.config.shapes.circle.style.border;
                
                // 更新维度标注
                this.updateCircleDimensions(this.start.x, this.start.y, radius);
            }
            
            // 初始化线条
            initLine(x, y) {
                this.currentShape.className = 'line';
                this.currentShape.style.left = x + 'px';
                this.currentShape.style.top = y + 'px';
                this.currentShape.style.width = '0px';
                this.currentShape.style.height = this.config.shapes.line.style.width; // 线条宽度
                this.currentShape.style.backgroundColor = this.config.shapes.line.style.color;
                this.currentShape.style.display = 'block';
                this.currentShape.style.transformOrigin = 'top left';
            }
            
            // 更新线条
            updateLine(currentX, currentY) {
                // 计算两点间距离
                const length = Math.sqrt(
                    Math.pow(currentX - this.start.x, 2) + 
                    Math.pow(currentY - this.start.y, 2)
                );
                
                // 计算旋转角度
                const angle = Math.atan2(
                    currentY - this.start.y,
                    currentX - this.start.x
                ) * 180 / Math.PI;
                
                // 设置线条长度和角度
                this.currentShape.style.width = length + 'px';
                this.currentShape.style.transform = `rotate(${angle}deg)`;
                
                // 更新维度标注
                this.updateLineDimensions(this.start.x, this.start.y, currentX, currentY);
            }
            
            // 添加位置标记点
            addPointMarker(x, y, isStart = true) {
                const marker = document.createElement('div');
                marker.className = isStart ? 'point-marker start-marker' : 'point-marker end-marker';
                marker.style.position = 'absolute';
                marker.style.left = x + 'px';
                marker.style.top = y + 'px';
                marker.style.width = '6px';
                marker.style.height = '6px';
                marker.style.borderRadius = '50%';
                marker.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
                marker.style.border = '1px solid rgba(0, 0, 0, 0.3)';
                marker.style.transform = 'translate(-50%, -50%)';
                marker.style.zIndex = '100';
                document.body.appendChild(marker);
                return marker;
            }

            // 创建维度标注
            createDimensionLabel() {
                // 清除之前的当前维度标注
                this.clearCurrentDimension();
                
                // 创建新的维度标注
                this.currentDimension = {
                    label: document.createElement('div'),
                    line: document.createElement('div'),
                    startMarker: document.createElement('div'),
                    endMarker: document.createElement('div'),
                    // 特定矩形维度的元素会在需要时创建
                    widthLabel: null,
                    heightLabel: null,
                    widthLine: null,
                    heightLine: null,
                    // 辅助延长线
                    extensionLines: []
                };
                
                // 设置基本样式
                this.currentDimension.label.className = 'dimension-label';
                this.currentDimension.line.className = 'dimension-line';
                this.currentDimension.startMarker.className = 'dimension-marker';
                this.currentDimension.endMarker.className = 'dimension-marker';
                
                // 添加到文档
                document.body.appendChild(this.currentDimension.label);
                document.body.appendChild(this.currentDimension.line);
                document.body.appendChild(this.currentDimension.startMarker);
                document.body.appendChild(this.currentDimension.endMarker);
                
                // 保存引用以便之后清理
                this.dimensionElements.labels.push(this.currentDimension.label);
                this.dimensionElements.lines.push(this.currentDimension.line);
                this.dimensionElements.markers.push(this.currentDimension.startMarker);
                this.dimensionElements.markers.push(this.currentDimension.endMarker);
            }
            
            // 更新矩形的维度标注
            updateRectangleDimensions(x1, y1, x2, y2) {
                if (!this.currentDimension) {
                    this.createDimensionLabel();
                }
                
                // 计算宽度和高度
                const width = Math.abs(x2 - x1);
                const height = Math.abs(y2 - y1);
                
                // 确定矩形的左上角和右下角坐标
                const left = Math.min(x1, x2);
                const top = Math.min(y1, y2);
                const right = Math.max(x1, x2);
                const bottom = Math.max(y1, y2);
                
                // 为矩形创建两个维度标注（宽度和高度）
                if (!this.currentDimension.widthLabel) {
                    // 创建宽度标注
                    this.currentDimension.widthLabel = document.createElement('div');
                    this.currentDimension.widthLabel.className = 'dimension-label';
                    document.body.appendChild(this.currentDimension.widthLabel);
                    this.dimensionElements.labels.push(this.currentDimension.widthLabel);
                    
                    // 创建高度标注
                    this.currentDimension.heightLabel = document.createElement('div');
                    this.currentDimension.heightLabel.className = 'dimension-label';
                    document.body.appendChild(this.currentDimension.heightLabel);
                    this.dimensionElements.labels.push(this.currentDimension.heightLabel);
                    
                    // 创建宽度线
                    this.currentDimension.widthLine = document.createElement('div');
                    this.currentDimension.widthLine.className = 'dimension-line';
                    document.body.appendChild(this.currentDimension.widthLine);
                    this.dimensionElements.lines.push(this.currentDimension.widthLine);
                    
                    // 创建高度线
                    this.currentDimension.heightLine = document.createElement('div');
                    this.currentDimension.heightLine.className = 'dimension-line';
                    document.body.appendChild(this.currentDimension.heightLine);
                    this.dimensionElements.lines.push(this.currentDimension.heightLine);
                    
                    // 创建垂直延伸线 (4条: 左下, 右下, 右上, 右下)
                    for (let i = 0; i < 4; i++) {
                        const extLine = document.createElement('div');
                        extLine.className = 'extension-line';
                        document.body.appendChild(extLine);
                        this.currentDimension.extensionLines.push(extLine);
                        this.dimensionElements.lines.push(extLine);
                    }
                }
                
                // 隐藏原来的通用标签和线条
                this.currentDimension.label.style.display = 'none';
                this.currentDimension.line.style.display = 'none';
                
                // 设置维度线的距离
                const lineOffset = 15; // 从矩形边到线的距离
                const extLength = 10; // 延伸线的长度
                
                // 更新宽度标注
                this.currentDimension.widthLabel.textContent = `${Math.round(width)}px`;
                this.currentDimension.widthLabel.style.display = 'block';
                this.currentDimension.widthLabel.style.left = (left + width / 2) + 'px';
                this.currentDimension.widthLabel.style.top = (bottom + lineOffset + 10) + 'px'; // 放在矩形下方
                
                // 更新高度标注
                this.currentDimension.heightLabel.textContent = `${Math.round(height)}px`;
                this.currentDimension.heightLabel.style.display = 'block';
                this.currentDimension.heightLabel.style.left = (right + lineOffset + 10) + 'px'; // 放在矩形右侧
                this.currentDimension.heightLabel.style.top = (top + height / 2) + 'px';
                
                // 更新宽度线
                this.currentDimension.widthLine.style.display = 'block';
                this.currentDimension.widthLine.style.width = width + 'px';
                this.currentDimension.widthLine.style.left = left + 'px';
                this.currentDimension.widthLine.style.top = (bottom + lineOffset) + 'px'; // 与矩形保持距离
                this.currentDimension.widthLine.style.transform = 'rotate(0deg)';
                
                // 更新高度线
                this.currentDimension.heightLine.style.display = 'block';
                this.currentDimension.heightLine.style.width = height + 'px';
                this.currentDimension.heightLine.style.left = (right + lineOffset) + 'px'; // 与矩形保持距离
                this.currentDimension.heightLine.style.top = top + 'px';
                this.currentDimension.heightLine.style.transform = 'rotate(90deg)';
                this.currentDimension.heightLine.style.transformOrigin = 'left top';
                
                // 更新延伸线 - 宽度线的两端垂直延伸线
                // 左侧垂直线
                this.currentDimension.extensionLines[0].style.display = 'block';
                this.currentDimension.extensionLines[0].style.height = extLength + 'px';
                this.currentDimension.extensionLines[0].style.left = left + 'px';
                this.currentDimension.extensionLines[0].style.top = (bottom + lineOffset - extLength/2) + 'px';
                
                // 右侧垂直线
                this.currentDimension.extensionLines[1].style.display = 'block';
                this.currentDimension.extensionLines[1].style.height = extLength + 'px';
                this.currentDimension.extensionLines[1].style.left = right + 'px';
                this.currentDimension.extensionLines[1].style.top = (bottom + lineOffset - extLength/2) + 'px';
                
                // 更新延伸线 - 高度线的两端水平延伸线
                // 上部水平线
                this.currentDimension.extensionLines[2].style.display = 'block';
                this.currentDimension.extensionLines[2].style.width = extLength + 'px';
                this.currentDimension.extensionLines[2].style.height = '1px';
                this.currentDimension.extensionLines[2].style.left = (right + lineOffset - extLength/2) + 'px';
                this.currentDimension.extensionLines[2].style.top = top + 'px';
                
                // 下部水平线
                this.currentDimension.extensionLines[3].style.display = 'block';
                this.currentDimension.extensionLines[3].style.width = extLength + 'px';
                this.currentDimension.extensionLines[3].style.height = '1px';
                this.currentDimension.extensionLines[3].style.left = (right + lineOffset - extLength/2) + 'px';
                this.currentDimension.extensionLines[3].style.top = bottom + 'px';
                
                // 更新端点标记（左上角和右下角）
                this.currentDimension.startMarker.style.left = left + 'px';
                this.currentDimension.startMarker.style.top = top + 'px';
                this.currentDimension.endMarker.style.left = right + 'px';
                this.currentDimension.endMarker.style.top = bottom + 'px';
            }
            
            // 更新圆形的维度标注
            updateCircleDimensions(centerX, centerY, radius) {
                if (!this.currentDimension) {
                    this.createDimensionLabel();
                }
                
                // 计算终点位置（与线条相似，从圆心到圆周上一点）
                const endX = centerX + radius;
                const endY = centerY;
                
                // 计算长度（取整的半径）
                const roundedRadius = Math.round(radius);
                
                // 创建垂直延伸线
                if (!this.currentDimension.extensionLines.length) {
                    // 创建两条垂直延伸线
                    for (let i = 0; i < 2; i++) {
                        const extLine = document.createElement('div');
                        extLine.className = 'extension-line';
                        document.body.appendChild(extLine);
                        this.currentDimension.extensionLines.push(extLine);
                        this.dimensionElements.lines.push(extLine);
                    }
                }
                
                // 设置延伸线的长度
                const extLength = 10;
                
                // 更新标签
                this.currentDimension.label.textContent = `${roundedRadius}px`;
                
                // 计算标签位置（在线段中点上方）
                const midX = (centerX + endX) / 2;
                const midY = centerY - 20; // 放在线上方，距离更远
                
                this.currentDimension.label.style.left = midX + 'px';
                this.currentDimension.label.style.top = midY + 'px';
                
                // 更新线条
                this.currentDimension.line.style.display = 'block';
                this.currentDimension.line.style.width = radius + 'px';
                this.currentDimension.line.style.left = centerX + 'px';
                this.currentDimension.line.style.top = centerY + 'px';
                this.currentDimension.line.style.transformOrigin = 'left center';
                this.currentDimension.line.style.transform = 'rotate(0deg)';
                
                // 更新起点垂直延伸线（圆心点处）
                this.currentDimension.extensionLines[0].style.display = 'block';
                this.currentDimension.extensionLines[0].style.height = extLength + 'px';
                this.currentDimension.extensionLines[0].style.left = centerX + 'px';
                this.currentDimension.extensionLines[0].style.top = (centerY - extLength / 2) + 'px';
                
                // 更新终点垂直延伸线（圆周点处）
                this.currentDimension.extensionLines[1].style.display = 'block';
                this.currentDimension.extensionLines[1].style.height = extLength + 'px';
                this.currentDimension.extensionLines[1].style.left = endX + 'px';
                this.currentDimension.extensionLines[1].style.top = (centerY - extLength / 2) + 'px';
                
                // 更新端点标记
                this.currentDimension.startMarker.style.left = centerX + 'px';
                this.currentDimension.startMarker.style.top = centerY + 'px';
                this.currentDimension.endMarker.style.left = endX + 'px';
                this.currentDimension.endMarker.style.top = centerY + 'px';
            }
            
            // 更新线条的维度标注
            updateLineDimensions(x1, y1, x2, y2) {
                if (!this.currentDimension) {
                    this.createDimensionLabel();
                }
                
                // 创建垂直延伸线
                if (!this.currentDimension.extensionLines.length) {
                    // 创建两条垂直于线段的延伸线
                    for (let i = 0; i < 2; i++) {
                        const extLine = document.createElement('div');
                        extLine.className = 'extension-line';
                        document.body.appendChild(extLine);
                        this.currentDimension.extensionLines.push(extLine);
                        this.dimensionElements.lines.push(extLine);
                    }
                }
                
                // 计算长度并取整
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const roundedLength = Math.round(length);
                
                // 计算角度
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                // 计算垂直于线的角度
                const perpAngle = angle + 90; // 垂直于线的角度（弧度）
                const perpRadians = perpAngle * Math.PI / 180;
                
                // 设置延伸线的长度
                const extLength = 10;
                
                // 更新标签
                this.currentDimension.label.textContent = `${roundedLength}px`;
                
                // 计算标签位置 (线段中点上方一点)
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const labelDistance = 20; // 标签到线的距离
                
                const labelX = midX + Math.cos(perpRadians) * labelDistance;
                const labelY = midY + Math.sin(perpRadians) * labelDistance;
                
                this.currentDimension.label.style.left = labelX + 'px';
                this.currentDimension.label.style.top = labelY + 'px';
                
                // 更新线条
                this.currentDimension.line.style.display = 'block';
                this.currentDimension.line.style.width = length + 'px';
                this.currentDimension.line.style.left = x1 + 'px';
                this.currentDimension.line.style.top = y1 + 'px';
                this.currentDimension.line.style.transformOrigin = 'left center';
                this.currentDimension.line.style.transform = `rotate(${angle}deg)`;
                
                // 更新起点垂直延伸线
                this.currentDimension.extensionLines[0].style.display = 'block';
                this.currentDimension.extensionLines[0].style.height = extLength + 'px';
                this.currentDimension.extensionLines[0].style.left = x1 + 'px';
                this.currentDimension.extensionLines[0].style.top = (y1 - extLength / 2) + 'px';
                this.currentDimension.extensionLines[0].style.transform = `rotate(${perpAngle}deg)`;
                this.currentDimension.extensionLines[0].style.transformOrigin = 'center top';
                
                // 更新终点垂直延伸线
                this.currentDimension.extensionLines[1].style.display = 'block';
                this.currentDimension.extensionLines[1].style.height = extLength + 'px';
                this.currentDimension.extensionLines[1].style.left = x2 + 'px';
                this.currentDimension.extensionLines[1].style.top = (y2 - extLength / 2) + 'px';
                this.currentDimension.extensionLines[1].style.transform = `rotate(${perpAngle}deg)`;
                this.currentDimension.extensionLines[1].style.transformOrigin = 'center top';
                
                // 更新端点标记
                this.currentDimension.startMarker.style.left = x1 + 'px';
                this.currentDimension.startMarker.style.top = y1 + 'px';
                this.currentDimension.endMarker.style.left = x2 + 'px';
                this.currentDimension.endMarker.style.top = y2 + 'px';
            }
            
            // 清除当前维度标注
            clearCurrentDimension() {
                if (this.currentDimension) {
                    // 当前维度标注保持显示，不再是活动维度标注
                    this.currentDimension = null;
                }
            }
            
            // 清除所有维度标注
            clearAllDimensions() {
                // 移除所有标签和线条
                this.dimensionElements.labels.forEach(label => {
                    if (label && label.parentNode) {
                        label.parentNode.removeChild(label);
                    }
                });
                this.dimensionElements.lines.forEach(line => {
                    if (line && line.parentNode) {
                        line.parentNode.removeChild(line);
                    }
                });
                this.dimensionElements.markers.forEach(marker => {
                    if (marker && marker.parentNode) {
                        marker.parentNode.removeChild(marker);
                    }
                });
                
                // 重置数组
                this.dimensionElements.labels = [];
                this.dimensionElements.lines = [];
                this.dimensionElements.markers = [];
                this.currentDimension = null;
            }

            // 清除所有已绘制的图形
            clearAllShapes() {
                // 选择所有绘制的形状和标记点
                const shapes = document.querySelectorAll('.rectangle, .circle, .line, .point-marker');
                
                // 逐个移除
                shapes.forEach(shape => {
                    if (shape && shape.parentNode) {
                        shape.parentNode.removeChild(shape);
                    }
                });
            }

            // Proposal 1的触摸开始处理函数
            handleTouchStartProposal1(e) {
                e.preventDefault();
                
                // 如果触摸在工具栏区域，不处理
                if (this.isInToolbarArea(e.target)) {
                    return;
                }
                
                // 如果没有选择绘图工具，不执行操作
                if (!this.activeShape) return;
                
                // 获取触摸位置
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY - 60; // 减去工具栏高度
                
                // 获取最近的网格点
                const { x: snappedX, y: snappedY, isSnapping } = this.getNearestGridPoint(touchX, touchY);
                
                // 更新光标位置
                const cursorTop = (snappedY - 35) + 'px';
                const cursorLeft = (snappedX - 35) + 'px';
                
                this.cursor.style.top = cursorTop;
                this.cursor.style.left = cursorLeft;
                this.snapCursor.style.top = cursorTop;
                this.snapCursor.style.left = cursorLeft;
                
                // 更新吸附状态（显示相应的光标）
                this.updateSnappingState(isSnapping);
                
                // 显示光标
                if (isSnapping) {
                    this.snapCursor.style.display = 'block';
                } else {
                    this.cursor.style.display = 'block';
                }
                
                // Proposal 1新逻辑：如果还没有放置第一个点，立即在光标位置放置第一个点
                if (!this.firstCornerPlaced) {
                    // 清除所有现有的维度标注
                    this.clearAllDimensions();
                    
                    // 创建新形状
                    this.currentShape = document.createElement('div');
                    this.currentShape.id = 'shape' + (++this.shapeCount);
                    this.currentShape.style.position = 'absolute';
                    document.body.appendChild(this.currentShape);
                    
                    // 记录起始点 - 使用当前光标位置
                    const cursorX = parseInt((isSnapping ? this.snapCursor : this.cursor).style.left) + 35;
                    const cursorY = parseInt((isSnapping ? this.snapCursor : this.cursor).style.top) + 35;
                    this.start = { x: cursorX, y: cursorY };
                    
                    // 添加起始点标记
                    this.startMarker = this.addPointMarker(cursorX, cursorY, true);
                    
                    // 根据形状类型初始化
                    switch (this.activeShape) {
                        case 'square':
                            this.initSquare(cursorX, cursorY);
                            break;
                        case 'circle':
                            this.initCircle(cursorX, cursorY);
                            break;
                        case 'line':
                            this.initLine(cursorX, cursorY);
                            break;
                    }
                    
                    this.firstCornerPlaced = true;
                    this.isDrawing = true;
                    
                    // 更新提示信息
                    const firstPointPlacedMessage = this.config.shapes[this.activeShape].initMessages.firstPlaced;
                    this.snackbar.innerHTML = `<p>${firstPointPlacedMessage}</p>`;
                }
            }

            // Proposal 1的触摸移动处理函数
            handleTouchMoveProposal1(e) {
                e.preventDefault();
                
                // 如果触摸在工具栏区域，隐藏光标
                if (this.isInToolbarArea(e.target)) {
                    this.cursor.style.display = 'none';
                    this.snapCursor.style.display = 'none';
                    return;
                }
                
                // 如果没有选择绘图工具，不执行操作
                if (!this.activeShape) return;
                
                // 计算触摸位置
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY - 60; // 减去工具栏高度
                
                // 获取最近的网格点
                const { x: snappedX, y: snappedY, isSnapping } = this.getNearestGridPoint(touchX, touchY);
                
                // 更新光标位置
                const cursorTop = (snappedY - 35) + 'px';
                const cursorLeft = (snappedX - 35) + 'px';
                
                this.cursor.style.top = cursorTop;
                this.cursor.style.left = cursorLeft;
                this.snapCursor.style.top = cursorTop;
                this.snapCursor.style.left = cursorLeft;
                
                // 更新吸附状态（显示相应的光标）
                this.updateSnappingState(isSnapping);
                
                // 如果正在绘制形状，根据不同形状类型进行处理
                if (this.isDrawing && this.start) {
                    // 使用吸附后的位置作为当前点
                    const currentX = snappedX;
                    const currentY = snappedY;
                    
                    switch (this.activeShape) {
                        case 'square':
                            this.updateSquare(currentX, currentY);
                            break;
                        case 'circle':
                            this.updateCircle(currentX, currentY);
                            break;
                        case 'line':
                            this.updateLine(currentX, currentY);
                            break;
                    }
                }
            }

            // Proposal 1的触摸结束处理函数
            handleTouchEndProposal1(e) {
                e.preventDefault();
                
                // 如果没有选择绘图工具，不执行操作
                if (!this.activeShape) return;
                
                // Proposal 1新逻辑：触摸结束时，直接完成图形绘制
                if (this.firstCornerPlaced && this.isDrawing) {
                    // 获取最后一个点的位置（当前光标位置）
                    const endX = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.left) + 35;
                    const endY = parseInt((this.isSnapping ? this.snapCursor : this.cursor).style.top) + 35;
                    
                    // 添加结束点标记（除了圆形外，因为圆形已经有中心点标记）
                    if (this.activeShape !== 'circle') {
                        this.addPointMarker(endX, endY, false);
                    }
                    
                    // 根据形状类型设置最终样式
                    switch (this.activeShape) {
                        case 'square':
                            this.currentShape.style.background = this.config.shapes.square.style.background;
                            break;
                        case 'circle':
                            this.currentShape.style.background = this.config.shapes.circle.style.background;
                            break;
                        case 'line':
                            // 线条已经有了样式
                            break;
                    }
                    
                    this.currentShape = null;
                    this.start = null;
                    this.isDrawing = false;
                    this.firstCornerPlaced = false;
                    
                    // 隐藏光标，等待下一次触摸
                    this.cursor.style.display = 'none';
                    this.snapCursor.style.display = 'none';
                    
                    // 更新提示信息
                    const completionMessage = this.config.shapes[this.activeShape].initMessages.completed;
                    this.snackbar.innerHTML = `<p>${completionMessage}</p>`;
                }
            }
        }

        // 窗口加载
        window.onload = function() {
            new ShapeDrawer();
        };
    </script>
</body>

</html>